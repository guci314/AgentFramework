# 认知工作流系统架构文档

## 1. 系统概述

### 1.1 系统简介
认知工作流系统（CognitiveWorkflow）是一个基于大语言模型的智能任务管理和执行框架。系统通过认知管理者统一调度任务规划、决策和执行，实现自适应的工作流管理。

### 1.2 设计理念
- **认知驱动**: 基于AI的智能决策和任务管理
- **自适应性**: 动态调整任务计划和执行策略
- **状态感知**: 基于全局状态的上下文感知决策
- **模块化**: 清晰的职责分离和组件解耦

### 1.3 核心特性
- 🧠 智能任务规划和动态调整
- 🔄 自适应工作流执行
- 📊 全局状态管理和跟踪
- 🛠️ 多智能体协作执行
- 🔍 先决条件智能检查
- 📈 执行历史和决策追踪

## 2. 系统架构概览

### 2.1 整体架构图

```mermaid
graph TB
    subgraph "用户接口层"
        UI["用户接口<br/>User Interface"]
        API["API接口<br/>API Gateway"]
    end
    
    subgraph "核心引擎层"
        Engine["认知工作流引擎<br/>CognitiveWorkflowEngine"]
    end
    
    subgraph "认知管理层"
        Manager["认知管理者<br/>CognitiveManager"]
        Executor["认知执行者<br/>CognitiveExecutor"]
    end
    
    subgraph "支持服务层"
        StateChecker["状态条件检查器<br/>StateConditionChecker"]
        GlobalState["全局状态管理<br/>GlobalState"]
    end
    
    subgraph "智能体层"
        Agents["智能体集群<br/>Agent Pool"]
        Agent1["分析师<br/>Analyst"]
        Agent2["编码者<br/>Coder"]
        Agent3["测试者<br/>Tester"]
    end
    
    subgraph "外部服务"
        LLM["大语言模型<br/>LLM Services"]
        Storage["持久化存储<br/>Storage"]
    end
    
    UI --> Engine
    API --> Engine
    Engine --> Manager
    Engine --> Executor
    Engine --> GlobalState
    Manager --> StateChecker
    Manager --> LLM
    Executor --> Agents
    Agents --> Agent1
    Agents --> Agent2
    Agents --> Agent3
    GlobalState --> Storage
    
    style Engine fill:#e1f5fe
    style Manager fill:#e8f5e8
    style Executor fill:#fff3e0
    style GlobalState fill:#f3e5f5
```

## 3. 核心组件类图

### 3.1 系统类图设计

```mermaid
classDiagram
    class CognitiveWorkflowEngine {
        -llm: BaseChatModel
        -agents: Dict[str, Agent]
        -manager: CognitiveManager
        -executor: CognitiveExecutor
        -global_state: GlobalState
        -task_list: List[CognitiveTask]
        -execution_history: List[Dict]
        -max_iterations: int
        -enable_auto_recovery: bool
        -interactive_mode: bool
        
        +execute_cognitive_workflow(goal: str, context: Dict) Dict
        +set_interactive_mode(interactive: bool) void
        +get_task_status_report() str
        -_initialize_workflow(goal: str, context: Dict) void
        -_update_global_state(task: CognitiveTask, result: Result) void
        -_handle_no_executable_tasks() bool
        -_apply_plan_modification(modification_decision: Dict) void
        -_add_dynamic_tasks(modification_decision: Dict) bool
        -_handle_task_failure(failed_task: CognitiveTask, result: Result) void
        -_generate_workflow_summary() Dict
    }
    
    class CognitiveManager {
        -llm: BaseChatModel
        -available_agents: Dict[str, Agent]
        -condition_checker: StateConditionChecker
        -interactive_mode: bool
        -decision_history: List[Dict]
        -management_statistics: Dict[str, int]
        
        +generate_initial_tasks(goal: str, context: Dict) List[CognitiveTask]
        +generate_dynamic_tasks(modification_context: Dict, global_state: GlobalState) List[CognitiveTask]
        +find_executable_tasks(task_list: List[CognitiveTask], global_state: GlobalState) List[Tuple[CognitiveTask, float]]
        +select_next_task(executable_tasks: List, global_state: GlobalState, execution_history: List) CognitiveTask
        +evaluate_workflow_status(task_list: List[CognitiveTask], global_state: GlobalState) Dict
        +analyze_modification_needs(task_list: List[CognitiveTask], global_state: GlobalState, last_execution_result: Result) Dict
        -_generate_tasks_from_prompt(system_prompt: str, user_prompt: str, task_type: str) List[CognitiveTask]
        -_create_task_from_data(task_data: Dict) CognitiveTask
        -_build_agent_info_string() str
        -_format_task_status(task_list: List[CognitiveTask]) str
        -_format_execution_history(execution_history: List[Dict]) str
        -_record_decision(decision_type: str, decision_data: Dict) void
    }
    
    class CognitiveExecutor {
        -agents: Dict[str, Agent]
        -execution_history: List[Dict]
        
        +execute_task(task: CognitiveTask, global_state: GlobalState) Result
        +get_execution_statistics() Dict
    }
    
    class StateConditionChecker {
        -llm: BaseChatModel
        
        +check_precondition_satisfied(precondition: str, global_state: GlobalState) Tuple[bool, float, str]
    }
    
    class GlobalState {
        +current_state: str
        +state_history: List[Tuple[str, str, datetime]]
        +context_variables: Dict[str, Any]
        +original_goal: str
        -_llm: BaseChatModel
        
        +set_llm(llm: BaseChatModel) void
        +set_original_goal(goal: str) void
        +update_state(new_state: str, source: str, task: CognitiveTask, result: Result, intelligent: bool) str
        +get_recent_history(limit: int) List[str]
        +get_state_summary() str
        -_update_state_internal(new_state: str, source: str) void
    }
    
    class CognitiveTask {
        +id: str
        +name: str
        +instruction: str
        +agent_name: str
        +instruction_type: str
        +phase: TaskPhase
        +expected_output: str
        +precondition: str
        +status: TaskStatus
        +result: Result
        +created_at: datetime
        +updated_at: datetime
        +execution_context: Dict[str, Any]
        
        +to_dict() Dict[str, Any]
    }
    
    class TaskPhase {
        <<enumeration>>
        INFORMATION
        EXECUTION
        VERIFICATION
    }
    
    class TaskStatus {
        <<enumeration>>
        PENDING
        EXECUTABLE
        RUNNING
        COMPLETED
        FAILED
        SKIPPED
        CANCELLED
    }
    
    class Agent {
        +name: str
        +api_specification: str
        
        +execute_sync(instruction: str) Result
        +chat_sync(instruction: str) Result
    }
    
    CognitiveWorkflowEngine --> CognitiveManager
    CognitiveWorkflowEngine --> CognitiveExecutor
    CognitiveWorkflowEngine --> GlobalState
    CognitiveWorkflowEngine --> CognitiveTask
    CognitiveManager --> StateConditionChecker
    CognitiveManager --> CognitiveTask
    CognitiveExecutor --> Agent
    CognitiveTask --> TaskPhase
    CognitiveTask --> TaskStatus
```

## 4. 核心交互流程

### 4.1 工作流执行主流程

```mermaid
sequenceDiagram
    participant User as 用户
    participant Engine as CognitiveWorkflowEngine
    participant Manager as CognitiveManager
    participant Executor as CognitiveExecutor
    participant State as GlobalState
    participant Checker as StateConditionChecker
    participant Agent as Agent
    
    User->>Engine: execute_cognitive_workflow(goal, context)
    
    Engine->>Manager: generate_initial_tasks(goal, context)
    Manager->>Manager: 调用LLM生成任务列表
    Manager-->>Engine: List[CognitiveTask]
    
    Engine->>State: update_state("工作流初始化完成")
    
    loop 工作流执行循环
        Engine->>Manager: find_executable_tasks(task_list, global_state)
        Manager->>Checker: check_precondition_satisfied(precondition, state)
        Checker->>Checker: LLM分析先决条件
        Checker-->>Manager: (satisfied, confidence, explanation)
        Manager-->>Engine: List[(task, confidence)]
        
        alt 有可执行任务
            Engine->>Manager: select_next_task(executable_tasks, state, history)
            Manager->>Manager: LLM智能选择
            Manager-->>Engine: selected_task
            
            Engine->>Executor: execute_task(selected_task, global_state)
            Executor->>Agent: execute_sync/chat_sync(instruction)
            Agent-->>Executor: Result
            Executor-->>Engine: Result
            
            Engine->>State: update_state(task, result)
            State->>State: 智能状态生成
        else 无可执行任务
            Engine->>Manager: analyze_modification_needs(task_list, state, result)
            Manager->>Manager: LLM分析修正需求
            Manager-->>Engine: modification_decision
            
            alt 需要动态修正
                Engine->>Manager: generate_dynamic_tasks(context, state)
                note right of Manager: 智能分析修正需求<br/>包括新任务、修复任务<br/>移除任务、修改任务
                Manager-->>Engine: List[CognitiveTask]
                Engine->>Engine: 应用动态修正
            end
        end
        
        Engine->>Manager: evaluate_workflow_status(task_list, state)
        Manager-->>Engine: workflow_status
        
        break 工作流完成
            Engine->>Engine: 所有任务完成或达到最大迭代次数
        end
    end
    
    Engine->>Engine: _generate_workflow_summary()
    Engine-->>User: 工作流执行结果
```

### 4.2 任务状态转换图

```mermaid
stateDiagram-v2
    [*] --> PENDING: 任务创建
    
    PENDING --> EXECUTABLE: 先决条件满足
    EXECUTABLE --> RUNNING: 开始执行
    RUNNING --> COMPLETED: 执行成功
    RUNNING --> FAILED: 执行失败
    
    FAILED --> PENDING: 动态任务修正
    PENDING --> SKIPPED: 条件不满足且无法修复
    PENDING --> CANCELLED: 用户取消
    
    COMPLETED --> [*]: 任务结束
    SKIPPED --> [*]: 任务结束
    CANCELLED --> [*]: 任务结束
    
    note right of EXECUTABLE: 通过StateConditionChecker<br/>检查先决条件
    note right of RUNNING: 由CognitiveExecutor<br/>调用智能体执行
    note right of FAILED: 触发CognitiveManager<br/>智能动态修正
```

## 5. 组件职责说明

### 5.1 CognitiveWorkflowEngine（认知工作流引擎）
- **核心职责**: 工作流生命周期管理和组件协调
- **主要功能**:
  - 工作流初始化和执行控制
  - 组件间协调和状态同步
  - 异常处理和恢复机制
  - 执行历史管理

### 5.2 CognitiveManager（认知管理者）
- **核心职责**: 统一的认知任务管理
- **主要功能**:
  - 任务规划：初始任务生成、动态任务修正（包括新任务添加、修复任务、任务移除/修改）
  - 任务决策：可执行任务查找、下一任务选择、工作流状态评估
  - 计划修正：需求分析、动态调整决策
  - 决策历史记录和统计

### 5.3 CognitiveExecutor（认知执行者）
- **核心职责**: 纯粹的任务执行
- **主要功能**:
  - 任务执行调度
  - 智能体交互管理
  - 执行结果处理
  - 执行统计收集

### 5.4 StateConditionChecker（状态条件检查器）
- **核心职责**: 智能状态分析
- **主要功能**:
  - 先决条件满足性检查
  - 置信度评估
  - 状态解释生成

### 5.5 GlobalState（全局状态）
- **核心职责**: 工作流状态管理
- **主要功能**:
  - 状态更新和历史记录
  - 上下文变量管理
  - 智能状态描述生成
  - 状态查询和摘要

## 6. 重构前后对比

### 6.1 架构演进图

```mermaid
graph TB
    subgraph "重构前架构"
        subgraph "CognitiveWorkflowEngine_v1"
            Engine1["工作流引擎"]
        end
        
        subgraph "认知组件_v1"
            Planner["CognitivePlanner<br/>规划者"]
            Decider["CognitiveDecider<br/>决策者"]
            Executor1["CognitiveExecutor<br/>执行者"]
        end
        
        subgraph "支持组件_v1"
            Checker1["StateConditionChecker<br/>状态检查器"]
            State1["GlobalState<br/>全局状态"]
        end
        
        Engine1 --> Planner
        Engine1 --> Decider
        Engine1 --> Executor1
        Decider --> Planner
        Decider --> Checker1
        Engine1 --> State1
    end
    
    subgraph "重构后架构"
        subgraph "CognitiveWorkflowEngine_v2"
            Engine2["工作流引擎"]
        end
        
        subgraph "认知组件_v2"
            Manager["CognitiveManager<br/>认知管理者"]
            Executor2["CognitiveExecutor<br/>执行者"]
        end
        
        subgraph "支持组件_v2"
            Checker2["StateConditionChecker<br/>状态检查器"]
            State2["GlobalState<br/>全局状态"]
        end
        
        Engine2 --> Manager
        Engine2 --> Executor2
        Manager --> Checker2
        Engine2 --> State2
    end
    
    style Planner fill:#ffcdd2
    style Decider fill:#ffcdd2
    style Manager fill:#c8e6c9
```

### 6.2 重构优势
1. **简化架构**: 从3个核心组件减少到2个
2. **消除重复**: 统一任务生成和决策逻辑
3. **提高维护性**: 相关功能集中管理
4. **保持功能完整性**: 所有现有功能都会保留
5. **智能修复整合**: 将修复任务生成整合到动态任务修正中，避免功能重叠

### 6.3 修复任务整合说明
**设计决策**: 将传统的独立修复任务生成机制整合到动态任务修正机制中。

**原因分析**:
- 动态任务添加功能的 `analyze_modification_needs()` 方法已经能够智能分析失败情况
- 可以根据任务失败、执行结果和全局状态生成针对性的修复策略
- 避免了两套修复机制的功能重叠和代码重复

**实现方式**:
- `analyze_modification_needs()` 分析修正需求时，会检测任务失败情况
- 当检测到需要修复时，返回 `action: "add_tasks"` 的修正决策
- `generate_dynamic_tasks()` 根据修正上下文生成相应的修复任务
- 修复任务通过统一的动态任务添加流程加入工作流

**优势**:
- 统一的修复策略和决策逻辑
- 更智能的上下文感知修复
- 简化的架构和更少的代码重复
- 更好的可维护性和扩展性

## 7. 关键设计模式

### 7.1 策略模式（Strategy Pattern）
**应用场景**: 任务生成策略
- **初始任务生成**: 基于目标的发散性规划
- **动态任务修正**: 基于上下文的智能修正（包括新任务添加、修复任务、任务移除/修改）

### 7.2 状态模式（State Pattern）
**应用场景**: 任务状态管理
- 不同状态下的任务行为不同
- 状态转换的条件和动作

### 7.3 观察者模式（Observer Pattern）
**应用场景**: 状态变更通知
- 任务状态变更时通知相关组件
- 全局状态更新时的事件传播

### 7.4 命令模式（Command Pattern）
**应用场景**: 任务执行
- 将任务指令封装为可执行对象
- 支持任务的重试、撤销等操作

## 8. 技术特色

### 8.1 核心特性
- **认知驱动**: 基于AI的智能工作流管理
- **状态感知**: 全局状态的智能分析和更新
- **动态适应**: 运行时的任务动态调整
- **先决条件**: 自然语言描述的智能条件检查
- **三阶段规划**: 信息收集→执行→验证的标准流程

### 8.2 应用场景
- **自动化运维**: 智能化的系统运维任务
- **代码开发**: AI辅助的软件开发流程
- **数据处理**: 复杂数据分析和处理流程
- **业务流程**: 智能化的业务流程自动化
- **研究分析**: 科研和分析任务的智能化管理

## 9. 总结

### 9.1 架构优势
1. **统一管理**: CognitiveManager统一任务管理职责
2. **职责清晰**: Manager负责认知，Executor负责执行
3. **高度解耦**: 组件间通过明确接口交互
4. **智能化**: 基于LLM的智能决策和状态管理
5. **可扩展**: 支持水平和垂直扩展
6. **可靠性**: 完善的容错和恢复机制

### 9.2 实施建议
建议按照以下顺序进行重构：
1. **第1周**: 设计确认和准备
2. **第2周**: 核心开发（CognitiveManager骨架）
3. **第3周**: 功能迁移和引擎更新
4. **第4周**: 测试优化和清理

---

**版本**: v2.0  
**更新日期**: 2024-12-21  
**文档状态**: 架构设计完成，待实施验证 