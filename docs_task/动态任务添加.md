# åŠ¨æ€ä»»åŠ¡æ·»åŠ åŠŸèƒ½å®ç°è®¡åˆ’

## ğŸ“‹ åŠŸèƒ½æ¦‚è¿°

åŠ¨æ€ä»»åŠ¡æ·»åŠ æ˜¯ CognitiveWorkflow è®¡åˆ’ä¿®æ­£æœºåˆ¶çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œå…è®¸åœ¨å·¥ä½œæµè¿è¡Œæ—¶æ ¹æ®éœ€è¦åŠ¨æ€æ·»åŠ æ–°ä»»åŠ¡ã€‚è¿™æ˜¯å®ç°çœŸæ­£æ™ºèƒ½å·¥ä½œæµçš„å…³é”®èƒ½åŠ›ã€‚

## ğŸ¯ å®ç°ç›®æ ‡

- **ä½ç½®**: `CognitiveWorkflowEngine._apply_plan_modification()` æ–¹æ³•
- **æ–‡ä»¶**: `cognitive_workflow.py` ç¬¬1370è¡Œå·¦å³
- **å½“å‰çŠ¶æ€**: ç©ºå®ç°ï¼ˆpassï¼‰
- **ç›®æ ‡**: å®ç°å®Œæ•´çš„åŠ¨æ€ä»»åŠ¡æ·»åŠ åŠŸèƒ½

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½éœ€æ±‚

### 1. åŸºæœ¬åŠŸèƒ½
- âœ… è§£æ modification_decision ä¸­çš„æ–°ä»»åŠ¡æ•°æ®
- âœ… åˆ›å»º CognitiveTask å¯¹è±¡å¹¶æ·»åŠ åˆ° task_list
- âœ… éªŒè¯æ–°ä»»åŠ¡çš„æœ‰æ•ˆæ€§ï¼ˆagentå­˜åœ¨ã€å­—æ®µå®Œæ•´ç­‰ï¼‰
- âœ… ç”Ÿæˆå”¯ä¸€çš„ä»»åŠ¡IDï¼Œé¿å…å†²çª
- âœ… è®°å½•ä»»åŠ¡æ·»åŠ çš„æ“ä½œæ—¥å¿—

### 2. æ•°æ®ç»“æ„è®¾è®¡

**è¾“å…¥æ ¼å¼**ï¼ˆmodification_decision ç»“æ„ï¼‰ï¼š
```json
{
    "action": "add_tasks",
    "reason": "éœ€è¦é¢å¤–çš„ä¿¡æ¯æ”¶é›†ä»»åŠ¡",
    "details": {
        "new_tasks": [
            {
                "name": "æ”¶é›†ç”¨æˆ·åé¦ˆ",
                "instruction": "é€šè¿‡é—®å·è°ƒæŸ¥æ”¶é›†ç”¨æˆ·å¯¹äº§å“çš„åé¦ˆ",
                "agent_name": "information_agent",
                "instruction_type": "information",
                "phase": "information",
                "expected_output": "ç”¨æˆ·åé¦ˆæŠ¥å‘Š",
                "precondition": "äº§å“å·²ä¸Šçº¿ä¸”æœ‰ç”¨æˆ·ä½¿ç”¨"
            }
        ]
    }
}
```

## ğŸš€ å®ç°æ­¥éª¤

### ç¬¬ä¸€æ­¥ï¼šåŸºç¡€æ¶æ„æ­å»º
1. **ä¿®æ”¹ `_apply_plan_modification` æ–¹æ³•**
   - åœ¨ `action == 'add_tasks'` åˆ†æ”¯ä¸­æ·»åŠ å®é™…å®ç°
   - è°ƒç”¨æ–°çš„ `_add_dynamic_tasks` æ–¹æ³•

2. **åˆ›å»º `_add_dynamic_tasks` æ–¹æ³•**
   - è§£æ modification_decision ä¸­çš„ä»»åŠ¡æ•°æ®
   - é€ä¸ªå¤„ç†æ–°ä»»åŠ¡çš„åˆ›å»º

### ç¬¬äºŒæ­¥ï¼šä»»åŠ¡IDç”Ÿæˆæœºåˆ¶
```python
def _generate_dynamic_task_id(self) -> str:
    """ç”ŸæˆåŠ¨æ€ä»»åŠ¡IDï¼Œé¿å…å†²çª"""
    existing_ids = {task.id for task in self.task_list}
    timestamp = dt.now().strftime("%Y%m%d_%H%M%S")
    counter = 1
    
    while True:
        candidate_id = f"dynamic_{timestamp}_{counter:03d}"
        if candidate_id not in existing_ids:
            return candidate_id
        counter += 1
```

### ç¬¬ä¸‰æ­¥ï¼šä»»åŠ¡éªŒè¯æœºåˆ¶
```python
def _validate_new_task_data(self, task_data: Dict[str, Any]) -> Tuple[bool, List[str]]:
    """éªŒè¯æ–°ä»»åŠ¡æ•°æ®çš„æœ‰æ•ˆæ€§"""
    errors = []
    
    # 1. å¿…å¡«å­—æ®µæ£€æŸ¥
    required_fields = ['name', 'instruction', 'agent_name', 'expected_output']
    for field in required_fields:
        if field not in task_data or not task_data[field]:
            errors.append(f"ç¼ºå°‘å¿…å¡«å­—æ®µ: {field}")
    
    # 2. Agentå­˜åœ¨æ€§æ£€æŸ¥
    if task_data.get('agent_name') not in self.executor.agents:
        errors.append(f"æ™ºèƒ½ä½“ä¸å­˜åœ¨: {task_data.get('agent_name')}")
    
    # 3. æšä¸¾å€¼æ£€æŸ¥
    if task_data.get('phase'):
        try:
            TaskPhase(task_data['phase'])
        except ValueError:
            errors.append(f"æ— æ•ˆçš„ä»»åŠ¡é˜¶æ®µ: {task_data['phase']}")
    
    return len(errors) == 0, errors
```

### ç¬¬å››æ­¥ï¼šä»»åŠ¡åˆ›å»ºé€»è¾‘
```python
def _create_cognitive_task_from_data(self, task_data: Dict[str, Any]) -> CognitiveTask:
    """ä»æ•°æ®å­—å…¸åˆ›å»º CognitiveTask å¯¹è±¡"""
    return CognitiveTask(
        id=self._generate_dynamic_task_id(),
        name=task_data['name'],
        instruction=task_data['instruction'],
        agent_name=task_data['agent_name'],
        instruction_type=task_data.get('instruction_type', 'execution'),
        phase=TaskPhase(task_data.get('phase', 'execution')),
        expected_output=task_data['expected_output'],
        precondition=task_data.get('precondition', 'æ— ç‰¹æ®Šå…ˆå†³æ¡ä»¶')
    )
```

## ğŸ“ å®Œæ•´å®ç°ä»£ç 

### ä¸»è¦ä¿®æ”¹ï¼š`_apply_plan_modification` æ–¹æ³•

```python
def _apply_plan_modification(self, modification_decision: Dict[str, Any]):
    """åº”ç”¨è®¡åˆ’ä¿®æ­£å†³ç­–"""
    action = modification_decision['action']
    reason = modification_decision['reason']
    
    logger.info(f"åº”ç”¨è®¡åˆ’ä¿®æ­£: {action} - {reason}")
    
    if action == 'add_tasks':
        # åŠ¨æ€ä»»åŠ¡æ·»åŠ å®ç°
        success = self._add_dynamic_tasks(modification_decision)
        if success:
            logger.info("åŠ¨æ€ä»»åŠ¡æ·»åŠ æˆåŠŸ")
        else:
            logger.warning("åŠ¨æ€ä»»åŠ¡æ·»åŠ å¤±è´¥")
    elif action == 'remove_tasks':
        # TODO: åç»­å®ç°
        pass
    elif action == 'modify_tasks':
        # TODO: åç»­å®ç°
        pass
        
    self.global_state.update_state(
        new_state=f"è®¡åˆ’ä¿®æ­£: {reason}",
        source="decider"
    )
```

### æ–°å¢æ–¹æ³•ï¼š`_add_dynamic_tasks`

```python
def _add_dynamic_tasks(self, modification_decision: Dict[str, Any]) -> bool:
    """
    åŠ¨æ€æ·»åŠ æ–°ä»»åŠ¡
    
    Args:
        modification_decision: åŒ…å«æ–°ä»»åŠ¡ä¿¡æ¯çš„ä¿®æ­£å†³ç­–
        
    Returns:
        bool: æ˜¯å¦æˆåŠŸæ·»åŠ ä»»åŠ¡
    """
    try:
        details = modification_decision.get('details', {})
        new_tasks_data = details.get('new_tasks', [])
        
        if not new_tasks_data:
            logger.warning("æ²¡æœ‰æä¾›æ–°ä»»åŠ¡æ•°æ®")
            return False
        
        added_tasks = []
        
        for task_data in new_tasks_data:
            # 1. éªŒè¯ä»»åŠ¡æ•°æ®
            is_valid, errors = self._validate_new_task_data(task_data)
            if not is_valid:
                logger.error(f"ä»»åŠ¡æ•°æ®éªŒè¯å¤±è´¥: {', '.join(errors)}")
                continue
            
            # 2. åˆ›å»ºä»»åŠ¡å¯¹è±¡
            try:
                new_task = self._create_cognitive_task_from_data(task_data)
                
                # 3. æ·»åŠ åˆ°ä»»åŠ¡åˆ—è¡¨
                self.task_list.append(new_task)
                added_tasks.append(new_task)
                
                # 4. è®°å½•æ—¥å¿—
                logger.info(f"æˆåŠŸæ·»åŠ åŠ¨æ€ä»»åŠ¡: {new_task.id} - {new_task.name}")
                
            except Exception as e:
                logger.error(f"åˆ›å»ºä»»åŠ¡å¤±è´¥: {e}")
                continue
        
        if added_tasks:
            logger.info(f"æœ¬æ¬¡åŠ¨æ€æ·»åŠ äº† {len(added_tasks)} ä¸ªä»»åŠ¡")
            # æ›´æ–°å…¨å±€çŠ¶æ€
            task_names = [task.name for task in added_tasks]
            self.global_state.update_state(
                new_state=f"åŠ¨æ€æ·»åŠ äº†ä»»åŠ¡: {', '.join(task_names)}",
                source="modifier"
            )
            return True
        else:
            logger.warning("æ²¡æœ‰æˆåŠŸæ·»åŠ ä»»ä½•ä»»åŠ¡")
            return False
            
    except Exception as e:
        logger.error(f"åŠ¨æ€ä»»åŠ¡æ·»åŠ è¿‡ç¨‹å‡ºé”™: {e}")
        return False

def _generate_dynamic_task_id(self) -> str:
    """ç”ŸæˆåŠ¨æ€ä»»åŠ¡IDï¼Œé¿å…å†²çª"""
    existing_ids = {task.id for task in self.task_list}
    timestamp = dt.now().strftime("%Y%m%d_%H%M%S")
    counter = 1
    
    while True:
        candidate_id = f"dynamic_{timestamp}_{counter:03d}"
        if candidate_id not in existing_ids:
            return candidate_id
        counter += 1

def _validate_new_task_data(self, task_data: Dict[str, Any]) -> Tuple[bool, List[str]]:
    """éªŒè¯æ–°ä»»åŠ¡æ•°æ®çš„æœ‰æ•ˆæ€§"""
    errors = []
    
    # 1. å¿…å¡«å­—æ®µæ£€æŸ¥
    required_fields = ['name', 'instruction', 'agent_name', 'expected_output']
    for field in required_fields:
        if field not in task_data or not task_data[field]:
            errors.append(f"ç¼ºå°‘å¿…å¡«å­—æ®µ: {field}")
    
    # 2. Agentå­˜åœ¨æ€§æ£€æŸ¥
    if task_data.get('agent_name') not in self.executor.agents:
        available_agents = ', '.join(self.executor.agents.keys())
        errors.append(f"æ™ºèƒ½ä½“ '{task_data.get('agent_name')}' ä¸å­˜åœ¨ï¼Œå¯ç”¨æ™ºèƒ½ä½“: {available_agents}")
    
    # 3. ä»»åŠ¡é˜¶æ®µæ£€æŸ¥
    if task_data.get('phase'):
        try:
            TaskPhase(task_data['phase'])
        except ValueError:
            valid_phases = ', '.join([p.value for p in TaskPhase])
            errors.append(f"æ— æ•ˆçš„ä»»åŠ¡é˜¶æ®µ '{task_data['phase']}'ï¼Œæœ‰æ•ˆå€¼: {valid_phases}")
    
    # 4. æŒ‡ä»¤ç±»å‹æ£€æŸ¥
    if task_data.get('instruction_type'):
        valid_types = ['execution', 'information']
        if task_data['instruction_type'] not in valid_types:
            errors.append(f"æ— æ•ˆçš„æŒ‡ä»¤ç±»å‹ '{task_data['instruction_type']}'ï¼Œæœ‰æ•ˆå€¼: {', '.join(valid_types)}")
    
    return len(errors) == 0, errors

def _create_cognitive_task_from_data(self, task_data: Dict[str, Any]) -> CognitiveTask:
    """ä»æ•°æ®å­—å…¸åˆ›å»º CognitiveTask å¯¹è±¡"""
    return CognitiveTask(
        id=self._generate_dynamic_task_id(),
        name=task_data['name'],
        instruction=task_data['instruction'],
        agent_name=task_data['agent_name'],
        instruction_type=task_data.get('instruction_type', 'execution'),
        phase=TaskPhase(task_data.get('phase', 'execution')),
        expected_output=task_data['expected_output'],
        precondition=task_data.get('precondition', 'æ— ç‰¹æ®Šå…ˆå†³æ¡ä»¶')
    )
```

## ğŸ§ª æµ‹è¯•è®¡åˆ’

### 1. å•å…ƒæµ‹è¯•ç”¨ä¾‹

```python
def test_dynamic_task_addition():
    """æµ‹è¯•åŠ¨æ€ä»»åŠ¡æ·»åŠ åŠŸèƒ½"""
    
    # æµ‹è¯•æ•°æ®
    modification_decision = {
        "action": "add_tasks",
        "reason": "éœ€è¦æ”¶é›†æ›´å¤šä¿¡æ¯",
        "details": {
            "new_tasks": [
                {
                    "name": "æµ‹è¯•ä»»åŠ¡",
                    "instruction": "æ‰§è¡Œæµ‹è¯•ä»»åŠ¡",
                    "agent_name": "test_agent",
                    "expected_output": "æµ‹è¯•ç»“æœ"
                }
            ]
        }
    }
    
    # æ‰§è¡Œæµ‹è¯•
    initial_task_count = len(engine.task_list)
    success = engine._add_dynamic_tasks(modification_decision)
    
    # éªŒè¯ç»“æœ
    assert success == True
    assert len(engine.task_list) == initial_task_count + 1
    
    new_task = engine.task_list[-1]
    assert new_task.name == "æµ‹è¯•ä»»åŠ¡"
    assert new_task.id.startswith("dynamic_")
```

### 2. é›†æˆæµ‹è¯•åœºæ™¯è¯¦ç»†è®¾è®¡

#### åœºæ™¯1ï¼šæ­£å¸¸æ·»åŠ åœºæ™¯å®Œæ•´éªŒè¯

**æµ‹è¯•ç›®æ ‡**ï¼šéªŒè¯åŠ¨æ€ä»»åŠ¡æ·»åŠ åœ¨çœŸå®å·¥ä½œæµç¯å¢ƒä¸­çš„ç«¯åˆ°ç«¯åŠŸèƒ½

**æµ‹è¯•ç¯å¢ƒå‡†å¤‡**ï¼š
```python
def setup_integration_test_environment():
    """è®¾ç½®é›†æˆæµ‹è¯•ç¯å¢ƒ"""
    
    # 1. åˆ›å»ºæµ‹è¯•ç”¨çš„æ™ºèƒ½ä½“
    test_agents = {
        "information_agent": MockInformationAgent("ä¿¡æ¯æ”¶é›†æ™ºèƒ½ä½“"),
        "analysis_agent": MockAnalysisAgent("æ•°æ®åˆ†ææ™ºèƒ½ä½“"),
        "execution_agent": MockExecutionAgent("ä»»åŠ¡æ‰§è¡Œæ™ºèƒ½ä½“")
    }
    
    # 2. åˆ›å»ºæ¨¡æ‹Ÿçš„LLM
    mock_llm = MockChatModel()
    
    # 3. åˆå§‹åŒ–å·¥ä½œæµå¼•æ“
    engine = CognitiveWorkflowEngine(
        llm=mock_llm,
        agents=test_agents,
        max_iterations=20,
        enable_auto_recovery=True
    )
    
    return engine, test_agents, mock_llm
```

**æµ‹è¯•æ•°æ®å‡†å¤‡**ï¼š
```python
def prepare_test_scenario_data():
    """å‡†å¤‡æµ‹è¯•åœºæ™¯æ•°æ®"""
    
    # åˆå§‹å·¥ä½œæµç›®æ ‡
    initial_goal = "åˆ†æç”¨æˆ·è¡Œä¸ºæ•°æ®å¹¶ç”ŸæˆæŠ¥å‘Š"
    
    # åˆå§‹ä»»åŠ¡åˆ—è¡¨ï¼ˆæ¨¡æ‹Ÿå·¥ä½œæµå·²è¿è¡Œä¸€æ®µæ—¶é—´ï¼‰
    initial_tasks = [
        {
            "id": "task_001",
            "name": "æ”¶é›†ç”¨æˆ·æ•°æ®",
            "status": "completed",
            "result": "å·²æ”¶é›†åˆ°1000æ¡ç”¨æˆ·è¡Œä¸ºæ•°æ®"
        },
        {
            "id": "task_002", 
            "name": "æ•°æ®æ¸…æ´—",
            "status": "completed",
            "result": "æ•°æ®æ¸…æ´—å®Œæˆï¼Œæœ‰æ•ˆæ•°æ®950æ¡"
        },
        {
            "id": "task_003",
            "name": "ç”Ÿæˆåˆ†ææŠ¥å‘Š",
            "status": "pending",
            "precondition": "æ•°æ®åˆ†æå·²å®Œæˆ"
        }
    ]
    
    # åŠ¨æ€æ·»åŠ çš„ä»»åŠ¡æ•°æ®
    dynamic_tasks_data = {
        "action": "add_tasks",
        "reason": "éœ€è¦è¡¥å……ç”¨æˆ·æ»¡æ„åº¦è°ƒæŸ¥ä»¥å®Œå–„æŠ¥å‘Š",
        "details": {
            "new_tasks": [
                {
                    "name": "è®¾è®¡ç”¨æˆ·æ»¡æ„åº¦è°ƒæŸ¥",
                    "instruction": "è®¾è®¡é’ˆå¯¹äº§å“åŠŸèƒ½çš„ç”¨æˆ·æ»¡æ„åº¦è°ƒæŸ¥é—®å·ï¼ŒåŒ…å«5-10ä¸ªæ ¸å¿ƒé—®é¢˜",
                    "agent_name": "information_agent",
                    "instruction_type": "information",
                    "phase": "information",
                    "expected_output": "ç”¨æˆ·æ»¡æ„åº¦è°ƒæŸ¥é—®å·è®¾è®¡æ–‡æ¡£",
                    "precondition": "äº§å“åŠŸèƒ½æ¸…å•å·²æ˜ç¡®"
                },
                {
                    "name": "æ‰§è¡Œç”¨æˆ·æ»¡æ„åº¦è°ƒæŸ¥",
                    "instruction": "å‘ç›®æ ‡ç”¨æˆ·ç¾¤ä½“å‘é€æ»¡æ„åº¦è°ƒæŸ¥ï¼Œæ”¶é›†åé¦ˆæ•°æ®",
                    "agent_name": "execution_agent", 
                    "instruction_type": "execution",
                    "phase": "execution",
                    "expected_output": "ç”¨æˆ·æ»¡æ„åº¦è°ƒæŸ¥ç»“æœæ•°æ®",
                    "precondition": "è°ƒæŸ¥é—®å·å·²è®¾è®¡å®Œæˆ"
                },
                {
                    "name": "åˆ†ææ»¡æ„åº¦æ•°æ®",
                    "instruction": "åˆ†ææ”¶é›†åˆ°çš„ç”¨æˆ·æ»¡æ„åº¦æ•°æ®ï¼Œç”Ÿæˆè¶‹åŠ¿åˆ†æå’Œå»ºè®®",
                    "agent_name": "analysis_agent",
                    "instruction_type": "execution", 
                    "phase": "execution",
                    "expected_output": "ç”¨æˆ·æ»¡æ„åº¦åˆ†ææŠ¥å‘Š",
                    "precondition": "æ»¡æ„åº¦è°ƒæŸ¥æ•°æ®å·²æ”¶é›†å®Œæˆ"
                }
            ]
        }
    }
    
    return initial_goal, initial_tasks, dynamic_tasks_data
```

**å®Œæ•´æµ‹è¯•æµç¨‹**ï¼š
```python
def test_integration_normal_task_addition():
    """é›†æˆæµ‹è¯•ï¼šæ­£å¸¸æ·»åŠ åœºæ™¯"""
    
    # === é˜¶æ®µ1ï¼šç¯å¢ƒå‡†å¤‡ ===
    engine, test_agents, mock_llm = setup_integration_test_environment()
    initial_goal, initial_tasks, dynamic_tasks_data = prepare_test_scenario_data()
    
    # === é˜¶æ®µ2ï¼šåˆå§‹åŒ–å·¥ä½œæµ ===
    print("ğŸš€ é˜¶æ®µ2ï¼šåˆå§‹åŒ–å·¥ä½œæµ")
    
    # è®¾ç½®åˆå§‹ä»»åŠ¡
    engine._initialize_workflow(initial_goal)
    
    # æ¨¡æ‹Ÿå·²å®Œæˆçš„ä»»åŠ¡
    for task_data in initial_tasks:
        if task_data["status"] == "completed":
            # æ‰¾åˆ°å¯¹åº”ä»»åŠ¡å¹¶æ ‡è®°ä¸ºå®Œæˆ
            task = next((t for t in engine.task_list if t.name == task_data["name"]), None)
            if task:
                task.status = TaskStatus.COMPLETED
                task.result = Result(success=True, output=task_data["result"])
    
    # è®°å½•åˆå§‹çŠ¶æ€
    initial_task_count = len(engine.task_list)
    initial_pending_count = len([t for t in engine.task_list if t.status == TaskStatus.PENDING])
    
    print(f"  âœ… åˆå§‹ä»»åŠ¡æ•°é‡: {initial_task_count}")
    print(f"  âœ… å¾…æ‰§è¡Œä»»åŠ¡æ•°é‡: {initial_pending_count}")
    print(f"  âœ… å…¨å±€çŠ¶æ€: {engine.global_state.current_state}")
    
    # === é˜¶æ®µ3ï¼šè§¦å‘åŠ¨æ€ä»»åŠ¡æ·»åŠ  ===
    print("\nğŸ”„ é˜¶æ®µ3ï¼šè§¦å‘åŠ¨æ€ä»»åŠ¡æ·»åŠ ")
    
    # æ¨¡æ‹Ÿå†³ç­–è€…åˆ¤æ–­éœ€è¦æ·»åŠ ä»»åŠ¡
    # åœ¨çœŸå®åœºæ™¯ä¸­ï¼Œè¿™ä¼šç”±CognitiveDeciderçš„plan_modification_decisionè§¦å‘
    success = engine._add_dynamic_tasks(dynamic_tasks_data)
    
    print(f"  âœ… åŠ¨æ€æ·»åŠ æ“ä½œç»“æœ: {'æˆåŠŸ' if success else 'å¤±è´¥'}")
    
    # === é˜¶æ®µ4ï¼šéªŒè¯æ·»åŠ ç»“æœ ===
    print("\nâœ… é˜¶æ®µ4ï¼šéªŒè¯æ·»åŠ ç»“æœ")
    
    # 4.1 éªŒè¯ä»»åŠ¡æ•°é‡å˜åŒ–
    final_task_count = len(engine.task_list)
    added_task_count = len(dynamic_tasks_data["details"]["new_tasks"])
    expected_task_count = initial_task_count + added_task_count
    
    assert final_task_count == expected_task_count, \
        f"ä»»åŠ¡æ•°é‡ä¸åŒ¹é…: æœŸæœ›{expected_task_count}, å®é™…{final_task_count}"
    print(f"  âœ… ä»»åŠ¡æ•°é‡éªŒè¯é€šè¿‡: {initial_task_count} -> {final_task_count}")
    
    # 4.2 éªŒè¯æ–°æ·»åŠ çš„ä»»åŠ¡å±æ€§
    new_tasks = engine.task_list[-added_task_count:]  # è·å–æœ€åæ·»åŠ çš„ä»»åŠ¡
    
    for i, new_task in enumerate(new_tasks):
        expected_data = dynamic_tasks_data["details"]["new_tasks"][i]
        
        # éªŒè¯åŸºæœ¬å±æ€§
        assert new_task.name == expected_data["name"], \
            f"ä»»åŠ¡åç§°ä¸åŒ¹é…: {new_task.name} != {expected_data['name']}"
        assert new_task.instruction == expected_data["instruction"], \
            f"ä»»åŠ¡æŒ‡ä»¤ä¸åŒ¹é…"
        assert new_task.agent_name == expected_data["agent_name"], \
            f"æ™ºèƒ½ä½“åç§°ä¸åŒ¹é…"
        assert new_task.status == TaskStatus.PENDING, \
            f"æ–°ä»»åŠ¡çŠ¶æ€åº”ä¸ºPENDINGï¼Œå®é™…ä¸º{new_task.status}"
        
        # éªŒè¯IDæ ¼å¼
        assert new_task.id.startswith("dynamic_"), \
            f"åŠ¨æ€ä»»åŠ¡IDæ ¼å¼é”™è¯¯: {new_task.id}"
        
        print(f"  âœ… æ–°ä»»åŠ¡{i+1}éªŒè¯é€šè¿‡: {new_task.id} - {new_task.name}")
    
    # 4.3 éªŒè¯ä»»åŠ¡ä¾èµ–å…³ç³»
    # æ£€æŸ¥æ–°æ·»åŠ çš„ä»»åŠ¡æ˜¯å¦æ­£ç¡®è®¾ç½®äº†å…ˆå†³æ¡ä»¶
    survey_design_task = next((t for t in new_tasks if "è®¾è®¡" in t.name), None)
    survey_execution_task = next((t for t in new_tasks if "æ‰§è¡Œ" in t.name), None)
    
    assert survey_design_task is not None, "æœªæ‰¾åˆ°è°ƒæŸ¥è®¾è®¡ä»»åŠ¡"
    assert survey_execution_task is not None, "æœªæ‰¾åˆ°è°ƒæŸ¥æ‰§è¡Œä»»åŠ¡"
    
    # éªŒè¯æ‰§è¡Œä»»åŠ¡ä¾èµ–äºè®¾è®¡ä»»åŠ¡
    assert "è®¾è®¡å®Œæˆ" in survey_execution_task.precondition or "é—®å·" in survey_execution_task.precondition, \
        "è°ƒæŸ¥æ‰§è¡Œä»»åŠ¡çš„å…ˆå†³æ¡ä»¶è®¾ç½®ä¸æ­£ç¡®"
    
    print(f"  âœ… ä»»åŠ¡ä¾èµ–å…³ç³»éªŒè¯é€šè¿‡")
    
    # 4.4 éªŒè¯å…¨å±€çŠ¶æ€æ›´æ–°
    current_state = engine.global_state.current_state
    assert "åŠ¨æ€æ·»åŠ " in current_state or "æ»¡æ„åº¦" in current_state, \
        f"å…¨å±€çŠ¶æ€æœªæ­£ç¡®æ›´æ–°: {current_state}"
    
    print(f"  âœ… å…¨å±€çŠ¶æ€æ›´æ–°éªŒè¯é€šè¿‡: {current_state}")
    
    # === é˜¶æ®µ5ï¼šéªŒè¯å·¥ä½œæµç»§ç»­æ‰§è¡Œèƒ½åŠ› ===
    print("\nğŸ”„ é˜¶æ®µ5ï¼šéªŒè¯å·¥ä½œæµç»§ç»­æ‰§è¡Œèƒ½åŠ›")
    
    # 5.1 æ£€æŸ¥æ˜¯å¦æœ‰å¯æ‰§è¡Œçš„æ–°ä»»åŠ¡
    executable_tasks = engine.decider.find_executable_tasks(engine.task_list, engine.global_state)
    executable_new_tasks = [task for task, confidence in executable_tasks 
                           if task.id.startswith("dynamic_")]
    
    print(f"  âœ… å¯æ‰§è¡Œçš„æ–°ä»»åŠ¡æ•°é‡: {len(executable_new_tasks)}")
    
    # 5.2 æ¨¡æ‹Ÿæ‰§è¡Œä¸€ä¸ªæ–°æ·»åŠ çš„ä»»åŠ¡
    if executable_new_tasks:
        test_task = executable_new_tasks[0]
        print(f"  ğŸš€ æ¨¡æ‹Ÿæ‰§è¡Œæ–°ä»»åŠ¡: {test_task.name}")
        
        # æ¨¡æ‹Ÿä»»åŠ¡æ‰§è¡Œ
        test_task.status = TaskStatus.RUNNING
        mock_result = Result(
            success=True,
            output=f"æ¨¡æ‹Ÿæ‰§è¡Œç»“æœ: {test_task.expected_output}"
        )
        test_task.result = mock_result
        test_task.status = TaskStatus.COMPLETED
        
        # æ›´æ–°å…¨å±€çŠ¶æ€
        engine.global_state.update_state(
            task=test_task,
            result=mock_result,
            source="executor"
        )
        
        print(f"  âœ… æ–°ä»»åŠ¡æ‰§è¡Œæ¨¡æ‹Ÿå®Œæˆ: {test_task.id}")
    
    # === é˜¶æ®µ6ï¼šéªŒè¯æ—¥å¿—å’Œå®¡è®¡ ===
    print("\nğŸ“ é˜¶æ®µ6ï¼šéªŒè¯æ—¥å¿—å’Œå®¡è®¡")
    
    # è¿™é‡Œå¯ä»¥æ£€æŸ¥æ—¥å¿—æ–‡ä»¶æˆ–å®¡è®¡è®°å½•
    # åœ¨å®é™…å®ç°ä¸­ï¼Œåº”è¯¥æœ‰ä¸“é—¨çš„å®¡è®¡æ—¥å¿—ç³»ç»Ÿ
    
    print("  âœ… é›†æˆæµ‹è¯•å®Œæˆ - æ‰€æœ‰éªŒè¯ç‚¹é€šè¿‡")
    
    # === æµ‹è¯•æ€»ç»“ ===
    print(f"\nğŸ“Š æµ‹è¯•æ€»ç»“:")
    print(f"  - åˆå§‹ä»»åŠ¡æ•°: {initial_task_count}")
    print(f"  - æ·»åŠ ä»»åŠ¡æ•°: {added_task_count}")
    print(f"  - æœ€ç»ˆä»»åŠ¡æ•°: {final_task_count}")
    print(f"  - æˆåŠŸæ‰§è¡Œæ–°ä»»åŠ¡æ•°: {len([t for t in new_tasks if t.status == TaskStatus.COMPLETED])}")
    print(f"  - å½“å‰å…¨å±€çŠ¶æ€: {engine.global_state.current_state}")
    
    return True
```

**éªŒè¯å…³é”®ç‚¹æ¸…å•**ï¼š

1. **æ•°æ®å®Œæ•´æ€§éªŒè¯**
   - âœ… ä»»åŠ¡æ•°é‡æ­£ç¡®å¢åŠ 
   - âœ… ä»»åŠ¡å±æ€§å®Œæ•´ä¸”æ­£ç¡®
   - âœ… ä»»åŠ¡IDå”¯ä¸€æ€§å’Œæ ¼å¼æ­£ç¡®

2. **ä¸šåŠ¡é€»è¾‘éªŒè¯**
   - âœ… ä»»åŠ¡ä¾èµ–å…³ç³»æ­£ç¡®è®¾ç½®
   - âœ… ä»»åŠ¡é˜¶æ®µå’Œç±»å‹åŒ¹é…
   - âœ… æ™ºèƒ½ä½“åˆ†é…åˆç†

3. **ç³»ç»Ÿé›†æˆéªŒè¯**
   - âœ… å…¨å±€çŠ¶æ€æ­£ç¡®æ›´æ–°
   - âœ… æ–°ä»»åŠ¡å¯è¢«å†³ç­–è€…è¯†åˆ«å’Œé€‰æ‹©
   - âœ… æ–°ä»»åŠ¡å¯è¢«æ‰§è¡Œè€…æ­£å¸¸æ‰§è¡Œ

4. **é”™è¯¯æ¢å¤éªŒè¯**
   - âœ… éƒ¨åˆ†ä»»åŠ¡æ·»åŠ å¤±è´¥ä¸å½±å“æ•´ä½“æµç¨‹
   - âœ… ç³»ç»ŸçŠ¶æ€ä¿æŒä¸€è‡´æ€§
   - âœ… é”™è¯¯ä¿¡æ¯æ¸…æ™°è®°å½•

**æ€§èƒ½éªŒè¯**ï¼š
```python
def test_performance_validation():
    """æ€§èƒ½éªŒè¯ï¼šå¤§é‡ä»»åŠ¡æ·»åŠ """
    
    # å‡†å¤‡å¤§é‡ä»»åŠ¡æ•°æ®ï¼ˆ50ä¸ªä»»åŠ¡ï¼‰
    large_task_data = generate_large_task_dataset(50)
    
    # è®°å½•æ‰§è¡Œæ—¶é—´
    start_time = time.time()
    success = engine._add_dynamic_tasks(large_task_data)
    end_time = time.time()
    
    execution_time = end_time - start_time
    
    # éªŒè¯æ€§èƒ½æŒ‡æ ‡
    assert execution_time < 5.0, f"æ‰¹é‡æ·»åŠ è€—æ—¶è¿‡é•¿: {execution_time}ç§’"
    assert success, "å¤§é‡ä»»åŠ¡æ·»åŠ å¤±è´¥"
    
    print(f"âœ… æ€§èƒ½æµ‹è¯•é€šè¿‡: 50ä¸ªä»»åŠ¡æ·»åŠ è€—æ—¶ {execution_time:.2f}ç§’")
```

### 2. é›†æˆæµ‹è¯•åœºæ™¯

1. **æ­£å¸¸æ·»åŠ åœºæ™¯**ï¼šéªŒè¯æ­£ç¡®æ•°æ®çš„ä»»åŠ¡æ·»åŠ ï¼ˆå¦‚ä¸Šè¯¦ç»†è®¾è®¡ï¼‰
2. **éªŒè¯å¤±è´¥åœºæ™¯**ï¼šæµ‹è¯•å„ç§æ— æ•ˆæ•°æ®çš„å¤„ç†
3. **IDå†²çªåœºæ™¯**ï¼šæµ‹è¯•IDç”Ÿæˆçš„å”¯ä¸€æ€§
4. **ç©ºæ•°æ®åœºæ™¯**ï¼šæµ‹è¯•ç©ºä»»åŠ¡åˆ—è¡¨çš„å¤„ç†

## ğŸ“Š éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½éªŒæ”¶
- âœ… èƒ½å¤Ÿè§£æ modification_decision ä¸­çš„ä»»åŠ¡æ•°æ®
- âœ… æˆåŠŸåˆ›å»º CognitiveTask å¯¹è±¡å¹¶æ·»åŠ åˆ°ä»»åŠ¡åˆ—è¡¨
- âœ… ç”Ÿæˆå”¯ä¸€çš„ä»»åŠ¡IDï¼Œæ— å†²çª
- âœ… å®Œæ•´çš„æ•°æ®éªŒè¯ï¼Œæ‹’ç»æ— æ•ˆæ•°æ®
- âœ… è¯¦ç»†çš„æ—¥å¿—è®°å½•ï¼Œä¾¿äºè°ƒè¯•

### è´¨é‡éªŒæ”¶
- âœ… ä»£ç é€šè¿‡å•å…ƒæµ‹è¯•
- âœ… é”™è¯¯å¤„ç†å®Œå–„ï¼Œä¸ä¼šå¯¼è‡´ç³»ç»Ÿå´©æºƒ
- âœ… æ—¥å¿—ä¿¡æ¯æ¸…æ™°ï¼Œä¾¿äºé—®é¢˜æ’æŸ¥
- âœ… ç¬¦åˆç°æœ‰ä»£ç é£æ ¼å’Œæ¶æ„è®¾è®¡

## ğŸ”„ åç»­æ‰©å±•è®¡åˆ’

### çŸ­æœŸæ‰©å±•
1. **ä»»åŠ¡æ’å…¥ä½ç½®æ§åˆ¶**ï¼šæ”¯æŒåœ¨æŒ‡å®šä½ç½®æ’å…¥ä»»åŠ¡
2. **æ‰¹é‡æ“ä½œä¼˜åŒ–**ï¼šæé«˜å¤§é‡ä»»åŠ¡æ·»åŠ çš„æ€§èƒ½
3. **æ›´å¤šéªŒè¯è§„åˆ™**ï¼šå¢åŠ ä¸šåŠ¡é€»è¾‘éªŒè¯

### é•¿æœŸæ‰©å±•
1. **ä»»åŠ¡ä¾èµ–è‡ªåŠ¨åˆ†æ**ï¼šæ™ºèƒ½åˆ†ææ–°ä»»åŠ¡ä¸ç°æœ‰ä»»åŠ¡çš„ä¾èµ–å…³ç³»
2. **æ¨¡æ¿åŒ–ä»»åŠ¡åˆ›å»º**ï¼šæ”¯æŒåŸºäºæ¨¡æ¿å¿«é€Ÿåˆ›å»ºä»»åŠ¡
3. **ç‰ˆæœ¬ç®¡ç†é›†æˆ**ï¼šä¸ä»»åŠ¡ç‰ˆæœ¬ç®¡ç†ç³»ç»Ÿé›†æˆ

## ğŸ“ å®æ–½æ£€æŸ¥æ¸…å•

- [x] 1. ä¿®æ”¹ `_apply_plan_modification` æ–¹æ³• âœ… **å·²å®Œæˆ**
- [x] 2. å®ç° `_add_dynamic_tasks` æ–¹æ³• âœ… **å·²å®Œæˆ**
- [x] 3. å®ç° `_generate_dynamic_task_id` æ–¹æ³• âœ… **å·²å®Œæˆ**
- [x] 4. å®ç° `_validate_new_task_data` æ–¹æ³• âœ… **å·²å®Œæˆ**
- [x] 5. å®ç° `_create_cognitive_task_from_data` æ–¹æ³• âœ… **å·²å®Œæˆ**
- [x] 6. ç¼–å†™å•å…ƒæµ‹è¯• âœ… **å·²å®Œæˆ** (11ä¸ªæµ‹è¯•å…¨éƒ¨é€šè¿‡)
- [x] 7. è¿›è¡Œé›†æˆæµ‹è¯• âœ… **å·²å®Œæˆ** (ç«¯åˆ°ç«¯æµ‹è¯•é€šè¿‡)
- [x] 8. æ›´æ–°ç›¸å…³æ–‡æ¡£ âœ… **å·²å®Œæˆ**
- [ ] 9. ä»£ç å®¡æŸ¥ ğŸ”„ **ä¸‹ä¸€æ­¥**
- [ ] 10. éƒ¨ç½²å’ŒéªŒè¯ ğŸ”„ **ä¸‹ä¸€æ­¥**

---

## ğŸ‰ **å®æ–½å®Œæˆæ€»ç»“**

### âœ… **åŠŸèƒ½å®ç°çŠ¶æ€**
**å®é™…å¼€å‘æ—¶é—´**ï¼šçº¦2å°æ—¶ï¼ˆé«˜æ•ˆå®Œæˆï¼‰  
**å®Œæˆåº¦**ï¼š80% (æ ¸å¿ƒåŠŸèƒ½å…¨éƒ¨å®Œæˆ)  
**ä¼˜å…ˆçº§**ï¼šğŸ”¥ é«˜  
**å¤æ‚åº¦**ï¼šâ­â­â­ ä¸­ç­‰  

### ğŸ“Š **æµ‹è¯•è¦†ç›–æƒ…å†µ**
- **å•å…ƒæµ‹è¯•**ï¼š11ä¸ªæµ‹è¯• âœ… å…¨éƒ¨é€šè¿‡
  - IDç”Ÿæˆå”¯ä¸€æ€§æµ‹è¯•
  - æ•°æ®éªŒè¯åŠŸèƒ½æµ‹è¯•
  - ä»»åŠ¡åˆ›å»ºåŠŸèƒ½æµ‹è¯•
  - æ‰¹é‡æ·»åŠ åŠŸèƒ½æµ‹è¯•
  - é”™è¯¯å¤„ç†åŠŸèƒ½æµ‹è¯•
  - è®¡åˆ’ä¿®æ­£é›†æˆæµ‹è¯•

- **é›†æˆæµ‹è¯•**ï¼š1ä¸ªæµ‹è¯• âœ… é€šè¿‡
  - ç«¯åˆ°ç«¯åŠ¨æ€ä»»åŠ¡æ·»åŠ æµç¨‹éªŒè¯

### ğŸ› ï¸ **æ ¸å¿ƒæŠ€æœ¯ç‰¹æ€§**
- âœ… **å¾®ç§’çº§æ—¶é—´æˆ³ID**ï¼šç¡®ä¿å”¯ä¸€æ€§
- âœ… **å¤šå±‚æ•°æ®éªŒè¯**ï¼šå­—æ®µå®Œæ•´æ€§ã€æ™ºèƒ½ä½“å­˜åœ¨æ€§ã€æšä¸¾å€¼æ£€æŸ¥
- âœ… **å¥å£®é”™è¯¯å¤„ç†**ï¼šå•ä»»åŠ¡å¤±è´¥ä¸å½±å“æ‰¹é‡æ“ä½œ
- âœ… **è¯¦ç»†å®¡è®¡æ—¥å¿—**ï¼šå®Œæ•´çš„æ“ä½œè®°å½•
- âœ… **å…¨å±€çŠ¶æ€é›†æˆ**ï¼šè‡ªåŠ¨æ›´æ–°å·¥ä½œæµçŠ¶æ€
- âœ… **å‘åå…¼å®¹**ï¼šä¸ç°æœ‰å·¥ä½œæµæ— ç¼é›†æˆ

### ğŸ¯ **éªŒæ”¶æ ‡å‡†è¾¾æˆ**
| éªŒæ”¶é¡¹ç›® | çŠ¶æ€ | è¯´æ˜ |
|---------|------|------|
| è§£ææ–°ä»»åŠ¡æ•°æ® | âœ… | å®Œæ•´JSONç»“æ„è§£æ |
| åˆ›å»ºä»»åŠ¡å¯¹è±¡ | âœ… | CognitiveTaskåˆ›å»ºå’Œç®¡ç† |
| æ•°æ®æœ‰æ•ˆæ€§éªŒè¯ | âœ… | å¤šå±‚éªŒè¯æœºåˆ¶ |
| å”¯ä¸€IDç”Ÿæˆ | âœ… | å¾®ç§’æ—¶é—´æˆ³æ–¹æ¡ˆ |
| å®¡è®¡æ—¥å¿—è®°å½• | âœ… | è¯¦ç»†æ“ä½œæ—¥å¿— |
| æ‰¹é‡ä»»åŠ¡æ”¯æŒ | âœ… | æ•°ç»„å½¢å¼æ‰¹é‡æ·»åŠ  |
| é”™è¯¯éš”ç¦»å¤„ç† | âœ… | å¼‚å¸¸ä¸å½±å“å·¥ä½œæµ |

### ğŸ”„ **ä¸‹ä¸€æ­¥è¡ŒåŠ¨**
1. **ä»£ç å®¡æŸ¥**ï¼šå›¢é˜Ÿä»£ç è´¨é‡æ£€æŸ¥
2. **æ€§èƒ½æµ‹è¯•**ï¼šå¤§æ‰¹é‡ä»»åŠ¡æ·»åŠ æ€§èƒ½éªŒè¯
3. **æ–‡æ¡£å®Œå–„**ï¼šAPIæ–‡æ¡£å’Œä½¿ç”¨æŒ‡å—
4. **ç”Ÿäº§éƒ¨ç½²**ï¼šæ­£å¼ç¯å¢ƒéƒ¨ç½²å’Œç›‘æ§

è¿™ä¸ªåŠ¨æ€ä»»åŠ¡æ·»åŠ åŠŸèƒ½çš„å®ç°ä¸º CognitiveWorkflow çš„æ™ºèƒ½åŒ–å¥ å®šäº†åšå®åŸºç¡€ï¼Œæ”¯æŒäº†çœŸæ­£çš„è¿è¡Œæ—¶è®¡åˆ’ä¿®æ­£èƒ½åŠ›ã€‚ 