# 通过自然语言集成微服务

本文档阐述了如何利用本代码框架，通过自然语言指令来集成和编排微服务。框架提供了两种核心方案，分别应对不同的业务场景和需求：动态智能编排 (`MultiStepAgent_v2`) 和静态声明式编排 (`MultiStepAgent_v3`)。

核心思想是：**将每个微服务封装成一个独立的 `Agent`，然后利用一个总协调器 `Agent` 来规划和执行跨服务的复杂任务。**

---

## 方案一：基于 `MultiStepAgent_v2` (动态智能编排方案)

此方案利用大语言模型（LLM）的动态规划和决策能力，使其像一个智能项目经理，能够根据自然语言描述的业务目标，实时地生成和调整执行计划。

### 核心思想

将微服务封装为 `Agent`，然后用自然语言描述一个跨服务的业务目标，由 `MultiStepAgent_v2` 动态地生成执行步骤并决定执行流程。

### 实现步骤

#### 1. 将微服务封装为 `Agent`

为每个微服务创建一个适配器 `Agent`，继承自 `pythonTask.Agent`。这个 `Agent` 负责调用微服务的API，并将微服务的能力通过 `api_specification` 属性进行描述。

**示例 `UserServiceAgent` (获取用户信息):**
```python
from pythonTask import Agent, Result
import requests

class UserServiceAgent(Agent):
    def __init__(self, llm):
        super().__init__(llm=llm, stateful=True)
        self.api_base_url = "http://user-service.internal"
        self.api_specification = "一个处理用户信息的智能体，可以根据用户ID获取用户姓名和邮箱。"

    def execute_sync(self, user_id: str) -> Result:
        try:
            response = requests.get(f"{self.api_base_url}/users/{user_id.strip()}")
            response.raise_for_status()
            return Result(success=True, return_value=response.json())
        except requests.exceptions.RequestException as e:
            return Result(success=False, stderr=str(e))
```

**示例 `NotificationServiceAgent` (发送通知):**
```python
class NotificationServiceAgent(Agent):
    def __init__(self, llm):
        super().__init__(llm=llm, stateful=True)
        self.api_base_url = "http://notification-service.internal"
        self.api_specification = "一个发送通知的智能体，可以向指定邮箱发送消息。"

    def execute_sync(self, instruction: str) -> Result:
        # instruction 格式应为 "邮箱地址:消息内容"
        try:
            email, message = instruction.split(":", 1)
            payload = {"email": email.strip(), "message": message.strip()}
            response = requests.post(f"{self.api_base_url}/send", json=payload)
            response.raise_for_status()
            return Result(success=True, stdout="通知发送成功。")
        except Exception as e:
            return Result(success=False, stderr=str(e))
```

#### 2. 实例化并注册 `Agent` 到 `MultiStepAgent_v2`

```python
from enhancedAgent_v2 import MultiStepAgent_v2
from pythonTask import llm_deepseek

# 实例化微服务 Agents
user_agent = UserServiceAgent(llm=llm_deepseek)
notification_agent = NotificationServiceAgent(llm=llm_deepseek)

# 实例化总协调器
coordinator_v2 = MultiStepAgent_v2(
    llm=llm_deepseek,
    use_autonomous_planning=True # 关键：使用自主规划模式
)

# 注册 Agents
coordinator_v2.register_agent(name="user_service", instance=user_agent)
coordinator_v2.register_agent(name="notification_service", instance=notification_agent)
```

#### 3. 通过自然语言执行跨服务任务

```python
# 定义一个跨服务的自然语言指令
main_instruction = "查询用户ID为 '42' 的信息，然后给他注册的邮箱发送一条消息，内容是 '您的年度报告已生成。'"

# 执行任务
summary = coordinator_v2.execute_multi_step(main_instruction)
print(summary)
```

### 工作流程

1.  **智能规划**：`plan_execution` 方法接收到指令后，会请求LLM根据已注册的`Agent`的能力，将任务分解为步骤。
2.  **步骤执行**：协调器按序执行计划中的每个步骤。`_generate_state_aware_instruction` 方法会自动将上一步的结果（如用户邮箱）注入到下一步的上下文中。
3.  **动态决策**：`make_decision` 方法会在每一步执行后（或失败时）再次调用LLM，判断是继续、重试还是中止，提供了极高的灵活性。

### 优缺点

*   **优点**:
    *   **极高的灵活性**：能理解模糊的自然语言指令，并动态调整计划。
    *   **快速原型开发**：无需编写固定的工作流文件，能快速验证复杂的业务逻辑。
    *   **强大的适应性**：当某个步骤失败时，`make_decision`可以智能地决定下一步操作。
*   **缺点**:
    *   **性能开销**：多次调用LLM进行规划和决策，延迟较高。
    *   **可靠性**：LLM的输出不是100%确定的，可能因模型版本或提示词微小变化而产生不同的计划。
    *   **调试困难**：由于流程是动态生成的，复现和调试特定问题可能比较困难。

---

## 方案二：基于 `MultiStepAgent_v3` (静态声明式编排方案)

此方案采用静态工作流定义，将业务流程固化在配置文件中，通过引擎确定性地执行。自然语言指令主要作为工作流的输入参数。

### 核心思想

将微服务封装为 `Agent`，在YAML文件中预先定义好调用这些 `Agent` 的工作流（包括步骤、顺序和控制逻辑），然后通过传入参数来触发这个固定的工作流。

### 实现步骤

#### 1. 将微服务封装为 `Agent`

这一步与方案一完全相同。你需要创建 `UserServiceAgent` 和 `NotificationServiceAgent`。

#### 2. 创建工作流定义文件 (`workflow.yaml`)

这是此方案的核心。你需要用YAML格式声明式地定义整个业务流程。

```yaml
# workflow.yaml
metadata:
  name: "user-notification-workflow"
  version: "1.0"
  description: "查询用户信息并发送通知的固定工作流"

# 定义工作流中可用的Agent
agents:
  - name: user_service
    description: "用于获取用户信息的服务"
  - name: notification_service
    description: "用于发送通知的服务"

# 定义工作流的输入参数
inputs:
  - name: user_id
    type: string
    description: "要查询的用户ID"
  - name: message_content
    type: string
    description: "要发送的通知内容"

# 定义工作流步骤
steps:
  - id: "get_user"
    name: "获取用户信息"
    agent_name: "user_service"
    # 指令可以使用输入参数，格式为 ${inputs.参数名}
    instruction: "${inputs.user_id}"
    expected_output: "包含用户信息的JSON对象"

  - id: "send_notification"
    name: "发送通知"
    agent_name: "notification_service"
    # 指令可以引用之前步骤的结果，格式为 ${steps.步骤ID.result.return_value}
    instruction: "${steps.get_user.result.return_value.email}:${inputs.message_content}"
    expected_output: "通知发送成功的消息"

# 定义控制流
control_flow:
  - type: "conditional_goto"
    # 如果获取用户失败，则直接跳转到结束
    condition: "steps.get_user.result.success == false"
    target_step: "end" # 'end' 是一个内置的终止状态
```

#### 3. 实例化 `MultiStepAgent_v3` 并执行工作流

```python
from static_workflow.MultiStepAgent_v3 import MultiStepAgent_v3
from pythonTask import llm_deepseek

# 实例化微服务 Agents (与方案一相同)
user_agent = UserServiceAgent(llm=llm_deepseek)
notification_agent = NotificationServiceAgent(llm=llm_deepseek)

# 实例化协调器
coordinator_v3 = MultiStepAgent_v3(
    llm=llm_deepseek,
    workflow_file='workflow.yaml' # 加载定义好的工作流
)

# 注册 Agents
coordinator_v3.register_agent(name="user_service", instance=user_agent)
coordinator_v3.register_agent(name="notification_service", instance=notification_agent)

# 通过JSON格式的字符串传入参数来执行
main_instruction = """
{
    "user_id": "42",
    "message_content": "您的年度报告已生成。"
}
"""
summary = coordinator_v3.execute_multi_step(main_instruction)
print(summary)
```

### 工作流程

1.  `MultiStepAgent_v3` 初始化时，`StaticWorkflowEngine` 会加载并解析 `workflow.yaml` 文件，构建出确定的执行图。
2.  调用 `execute_multi_step` 时，它会将 `main_instruction` (JSON字符串) 解析为工作流的输入参数。
3.  引擎按照YAML中定义的 `steps` 顺序执行，并使用 `VariableInterpolator` 替换指令中的 `${...}` 占位符。
4.  `ControlFlowEvaluator` 会在每一步之后检查 `control_flow` 中定义的条件，并根据结果决定是继续还是跳转。这个过程是确定性的，不涉及LLM。

### 优缺点

*   **优点**:
    *   **高可靠性和确定性**：执行流程固定，每次执行结果都可预测。
    *   **高性能**：控制流判断不依赖LLM，执行速度快。
    *   **易于调试和维护**：工作流逻辑清晰地定义在YAML文件中，易于理解、修改和版本控制。
    *   **安全**：表达式求值在 `SafeEvaluator` 中进行，避免了不安全的代码执行。
*   **缺点**:
    *   **灵活性较低**：无法处理未在YAML中定义的模糊指令或异常情况。
    *   **初始设置成本高**：需要预先设计并编写详细的工作流定义文件。

---

## 总结与如何选择

| 特性 | 方案一 (MultiStepAgent_v2 - 动态) | 方案二 (MultiStepAgent_v3 - 静态) |
| :--- | :--- | :--- |
| **核心思想** | AI驱动的智能项目经理 | 预定义的自动化装配线 |
| **编排方式** | LLM在运行时动态生成计划和决策 | 加载预定义的YAML工作流文件 |
| **灵活性** | **高**，能处理模糊指令和未知情况 | **低**，流程固定，变更需修改配置 |
| **性能** | **低**，依赖多次LLM调用，延迟高 | **高**，确定性执行，延迟低 |
| **可靠性** | **中**，受LLM稳定性影响 | **高**，流程确定，结果可预测 |
| **适用场景** | 快速原型、探索性任务、内部工具 | 生产环境、核心业务流程、高可靠性场景 |

### 选择建议

*   **如果你处于项目早期，需要快速验证和迭代复杂的业务逻辑，或者你的用户输入非常多样化和模糊**，请选择 **方案一 (`v2`)**。它能让你用最快的速度将想法变为现实。
*   **如果你的业务流程已经稳定，需要构建一个可靠、高性能、可维护的生产级系统**，请选择 **方案二 (`v3`)**。它能提供企业级的稳定性和性能保障。

在实际应用中，两者也可以结合使用：使用 `v2` 快速探索和确定最佳业务流程，一旦流程稳定下来，就将其固化为 `v3` 的静态工作流以部署到生产环境。
